* Homotopy Type Theory

- [[/Type_Theory.org#inference-rules][inference rules]]
- [[/Type_Theory.org#universes][universes]]
- [[/Type_Theory.org#basic-types][basic types]]
 - [[/Type_Theory.org#empty-type][empty type]]
 - [[/Type_Theory.org#unit-type][unit type]]
 - [[/Type_Theory.org#natural-numbers][natural numbers]]
 - [[/Type_Theory.org#product-type][product type]]
 - [[/Type_Theory.org#sum-type][sum type]]
 - [[/Type_Theory.org#function-type][function type]]
- [[/Type_Theory.org#dependent-types][dependent types]]
 - [[/Type_Theory.org#dependent-sum][dependent sum]]
 - [[/Type_Theory.org#dependent-product][dependent product]]
 - [[/Type_Theory.org#identity-type][identity type]]

** inference rules
- formation rules - how to build type (declare type)  
- introduction rules (constructors) - how to create elements  
- elimination rules (induction principle) - how to use elements (to build dependent function)  
- computation rules - what will happen when we introduce and then eliminate (how to apply dependent function)  
- uniqueness rules - if we eliminate and introduce we should get judgmentaly equal result


** universes

We cannot allow to have rule Γ ⊢ U : U because this leads to paradoxes: [[https://en.wikipedia.org/wiki/Burali-Forti_paradox][Burali-Forti_paradox]],
[[https://en.wikipedia.org/wiki/Russell%27s_paradox][Russell's paradox]].

#+BEGIN_SRC

------------------- (Univ-I)
Γ ⊢ U(i) : U(i+1)
#+END_SRC


#+BEGIN_SRC
Γ ⊢ A : U(i)
--------------- (Univ-Cumul)
Γ ⊢ A : U(i+1)
#+END_SRC

* basic types

** product type
pair, tuple

- formation rule

#+BEGIN_SRC
A type  A type
-------------- (*F)
A * B type
#+END_SRC

- introduction rule

#+BEGIN_SRC
m: A  n: B
----------- (*I)
(m,n): A*B
#+END_SRC

- elimination rules

#+BEGIN_SRC
ab: A * B
----------- (*E1)
fst(ab) : A
#+END_SRC

#+BEGIN_SRC
ab: A * B
----------- (*E2)
snd(ab): B
#+END_SRC

- computation rules (introduce and then eliminate)

#+BEGIN_SRC
m: A  n: B
--------------- (*C1)
fst((m,n)) == m
#+END_SRC

#+BEGIN_SRC
m: A  n: B
--------------- (*C2)
snd((m,n)) == n
#+END_SRC

- uniqueness rules (eliminate and introduce we get the same):

#+BEGIN_SRC
ab: A * B
------------------------------ (*U)
ab == (fst(ab),snd(ab)): A * B
#+END_SRC

- Agda code

#+BEGIN_SRC Agda
record _*_ (S : Type UnivU)(T : Type UnivV) : Type (UnivU umax UnivV)  where
  constructor _,_
  field
    fst : S
    snd : T
#+END_SRC

** sum type
Either, disjoint sum

- formation rules

#+BEGIN_SRC
A type   B type
---------------- +-form
A + B type
#+END_SRC

- introduction rules

#+BEGIN_SRC
m: A
--------------- +-Intro-1
left(m): A + B

n: B
---------------- +-Intro-2
right(n): A + B
#+END_SRC

- elimination rule

#+BEGIN_SRC
x: A ⊢ m: C   y:B ⊢ n: C   o: A+B
---------------------------------- +-Elim
case(x.m;y.n;o): C
#+END_SRC

- computation rules

#+BEGIN_SRC
x: A ⊢ m: C   y:B ⊢ n: C   o: A
------------------------------------ +-Elim
case(x.m;y.n;left(o)) == m[o/x] : C
#+END_SRC

#+BEGIN_SRC
x: A ⊢ m: C   y:B ⊢ n: C   o: B
------------------------------------- +-Elim
case(x.m;y.n;right(o)) == n[o/x] : C
#+END_SRC

- Agda code

#+BEGIN_SRC Agda
data _+_ (X : Type UnivU) (Y : Type UnivV) : Type (UnivU umax UnivV) where
 Left : X -> X + Y
 Right : Y -> X + Y

+-induction : {X : Type UnivU} {Y : Type UnivV} (P : X + Y -> Type UnivW)
 -> ((x : X) -> P (Left  x))
 -> ((y : Y) -> P (Right y))
 -> (z : X + Y) -> P z
+-induction P f _ (Left x) = f x
+-induction P _ g (Right y) = g y

+-recursion : {X : Type UnivU} {Y : Type UnivV} (P : Type UnivW)
 -> (X -> P)
 -> (Y -> P)
 -> (X + Y) -> P
+-recursion P xp yp xy = +-induction (\ XY -> P) xp yp xy
#+END_SRC

** unit type
1, top

- formation rule

#+BEGIN_SRC

--------- 1-Form
One type
#+END_SRC

- introduction rule

#+BEGIN_SRC

--------- 1-Intro
<> : One
#+END_SRC

- no elimination rules

- no computation rules

- uniqueness rule

#+BEGIN_SRC

m: One
------------- 1-Uniq
m == <> : One
#+END_SRC

- Agda code:

#+BEGIN_SRC Agda
data One : Type Univ0 where
  <> : One

One-induction : (P : One -> Type UnivU)
  -> P <>
  -> (x : One) -> P x
One-induction P a <> = a

-- logic: P => (True -> P)
One-recursion : (P : Type UnivU) ->
  P ->
  (One -> P)
One-recursion P a x = One-induction (\ _ -> P) a x

-- unique function from any type to One (logic: A => True)
unit : {A : Type UnivU} -> A -> One
unit x = <>
#+END_SRC

** empty type
bottom, void, 0

- formation

#+BEGIN_SRC

----------- 0-Form
Zero type
#+END_SRC

- no introduction rules

- elimination rule

#+BEGIN_SRC
m: Zero
------------- 0-Elim
absurd(m) : C
#+END_SRC

- no computation rules

- Agda code

#+BEGIN_SRC Agda
data Zero : Type Univ0 where

Zero-induction : (P : Zero -> Type UnivU) -> (x : Zero) -> P x
Zero-induction A ()

Zero-recursion : (A : Type UnivU) -> Zero -> A
Zero-recursion A a = Zero-induction (\ _ -> A) a

absurd : (A : Type UnivU) -> Zero -> A
absurd = Zero-recursion
#+END_SRC

** function type

* Dependent Types

** dependent sum

** dependent function

- formation rule

#+BEGIN_SRC
Γ ⊢ A : Univ(i)   Γ,x:A ⊢ B x : Univ(i)
------------------------------------- Π-form
Γ ⊢ Π x:A -> B x : Univ(i)  
#+END_SRC

- introduction rule

#+BEGIN_SRC
Γ, x:A ⊢ b:B x
---------------------------------- Π-intro
Γ ⊢ λ (x:A) -> b : Π (x:A) -> B x  
#+END_SRC

- elimination rule

#+BEGIN_SRC
Γ ⊢ f : Π (x:A) -> B x    Γ ⊢ a:A
---------------------------------- Π-elim
Γ ⊢ f(a) : B a
#+END_SRC

- computation rule

#+BEGIN_SRC
Γ, x:A ⊢ b:B x   Γ ⊢ a:A
-------------------------------------- Π-comp-beta
Γ ⊢ (λ (x:A) -> b)(a) == b[x:=a] : B a
#+END_SRC

- uniqueness rule

#+BEGIN_SRC
Γ ⊢ f : Π (x:A) -> B x
---------------------------------------- Π-comp-eta
Γ ⊢ f == (λ x -> f(x)) : Pi (x:A) -> B x
#+END_SRC

** identity type

- formation rule

#+BEGIN_SRC
A type   m: A   n: A
--------------------- (Id-Form)
Id(A)(m,n) type
#+END_SRC

- introduction rule

#+BEGIN_SRC
m: A
-------------------- (Id-Intro)
refl(m): Id(A)(m,m)
#+END_SRC

- elimination rule

#+BEGIN_SRC
A type   n:A   o:A   p:Id(A)(n;o)
x:A,y:A,q:Id(x;y) ⊢ C type
z: A ⊢ m : C[x -> z, y -> z, q -> refl(z)]
-------------------------------------------- (Id-Elim)
J[X.y.q.C](z.M;p): C[x -> n, y -> o, q -> p]
#+END_SRC

- computation rule

#+BEGIN_SRC
A type n:A o:A
x:A,y:A,q:Id(A)(x;y) ⊢ C type
z:A ⊢ m: C[x -> z, y -> z, q -> refl(z)]
-------------------------------------------------------------- (Id-Comp)
J[X.y.q.C](z.M;refl(n)) == m[z -> n]: C[x -> n, y -> o, q -> p]
#+END_SRC

** equality types
- equality types and judgemental equality are equivalent
- equality types are internalization of judgemental equality
- rules all rules o Identification +

equality reflection rule:

#+BEGIN_SRC
Γ ⊢ p : Eq(A)(m;n)
-------------------- (Eq-Ref)
Γ ⊢ m == n : A
#+END_SRC

#+BEGIN_SRC
Γ ⊢ m == n : A
----------------------- (Eq-RefInv)
Γ ⊢ refl(m): Eq(A)(m;n)
#+END_SRC

uniqueness rule

#+BEGIN_SRC
p: Eq(A)(m;n)
----------------------- (Eq-Uniq)
p == refl : Eq(A)(m;n)
#+END_SRC
